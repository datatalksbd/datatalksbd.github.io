<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Advanced Graph Maker with AI Copilot</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/hammerjs@2.0.8"></script>
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-zoom@2.0.1/dist/chartjs-plugin-zoom.min.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        :root {
            --bg-primary: #121217;
            --bg-secondary: #1a1a23;
            --bg-tertiary: #2a2a35;
            --text-primary: #e4e6eb;
            --text-secondary: #8b8d98;
            --accent-primary: #4a90e2;
            --accent-hover: #3b78c2;
            --border-color: #374151;
            --error-color: #ef4444;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        html, body {
            height: 100%;
            background: var(--bg-primary);
            color: var(--text-primary);
            font-family: 'Segoe UI', sans-serif;
            font-size: 14px;
        }
        .main-container { padding: 15px; width: 100%; max-width: 1600px; margin: auto; display: flex; flex-direction: column; gap: 15px; }
        .controls-panel, .chart-area-wrapper { background: var(--bg-secondary); border-radius: 12px; padding: 15px; box-shadow: 0 8px 24px rgba(0,0,0,0.6); }
        .chart-area-wrapper { flex-grow: 1; } /* Allow chart area to take available space */

        h2.panel-title { font-size: 1.5rem; font-weight: 600; margin-bottom: 1rem; text-align: center; border-bottom: 1px solid var(--border-color); padding-bottom: 0.75rem; }
        h3.control-section-title { font-size: 1.125rem; font-weight: 500; margin-top: 1rem; margin-bottom: 0.75rem; color: var(--accent-primary); border-bottom: 1px solid var(--bg-tertiary); padding-bottom: 0.5rem; }

        .control-group { margin-bottom: 0.75rem; }
        .control-group label { display: block; margin-bottom: 0.375rem; font-weight: 500; color: var(--text-secondary); font-size: 0.875rem; }
        .control-group input[type="text"],
        .control-group input[type="number"],
        .control-group input[type="color"],
        .control-group select,
        .control-group textarea {
            width: 100%;
            padding: 0.5rem;
            border-radius: 0.375rem;
            background-color: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-color);
            font-size: 0.875rem;
        }
        .control-group input[type="checkbox"] { margin-right: 0.5rem; accent-color: var(--accent-primary); }
        .control-group input:focus, .control-group select:focus, .control-group textarea:focus { outline: 2px solid var(--accent-primary); border-color: var(--accent-primary); }
        .control-group button {
            padding: 0.5rem 1rem; background-color: var(--accent-primary); color: white;
            border-radius: 0.375rem; border: none; cursor: pointer; transition: background-color 0.2s;
            font-size: 0.875rem; margin-top: 0.25rem;
        }
        .control-group button:hover { background-color: var(--accent-hover); }
        .dataset-controls { border: 1px solid var(--bg-tertiary); padding: 10px; margin-bottom:10px; border-radius: 8px; }

        .grid-cols-controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; }

        #chartContainerWrapper { position: relative; width: 100%; height: 400px; min-height: 300px; } /* Adjusted for responsiveness */

        #errorDisplay { color: var(--error-color); text-align: center; margin-top: 1rem; font-size: 0.875rem; }

        /* Chat styles from previous example - slightly condensed */
        .chat-container { position: fixed; right: 15px; bottom: 15px; width: 320px; height: 420px; background: var(--bg-secondary); border-radius: 12px; box-shadow: 0 8px 24px rgba(0,0,0,0.8); resize: both; overflow: auto; min-width: 250px; min-height: 250px; z-index: 1000; display: none; flex-direction: column; }
        .chat-header { background: linear-gradient(90deg, #333, var(--bg-tertiary)); padding: 12px 15px; text-align: center; font-size: 1.1rem; font-weight: 600; border-bottom: 1px solid var(--border-color); border-top-left-radius: 12px; border-top-right-radius: 12px; display: flex; justify-content: space-between; align-items: center; cursor: grab; user-select: none; }
        #close-chat { background: none; border: none; color: var(--text-primary); font-size: 1.5rem; cursor: pointer; }
        .chat-messages { flex: 1; padding: 10px; overflow-y: auto; display: flex; flex-direction: column; gap: 10px; }
        .message { display: flex; align-items: flex-end; animation: fadeIn 0.2s ease-out; } .message.user { flex-direction: row-reverse; }
        .avatar { width: 30px; height: 30px; border-radius: 50%; background: var(--bg-tertiary); display: flex; align-items: center; justify-content: center; font-weight: bold; color: var(--text-secondary); margin: 0 8px; flex-shrink: 0; font-size:0.8rem; }
        .bubble { max-width: 80%; padding: 8px 12px; border-radius: 12px; background: var(--bg-tertiary); box-shadow: inset 0 0 1px rgba(0,0,0,0.5), 0 1px 3px rgba(0,0,0,0.4); word-break: break-word; font-size:0.875rem; }
        .message.user .bubble { background: #3a3a4a; }
        .chat-input { display: flex; padding: 10px; border-top: 1px solid var(--border-color); }
        .chat-input textarea { flex: 1; padding: 8px; border-radius: 8px; background: var(--bg-tertiary); color: var(--text-primary); font-size: 0.875rem; resize: none; border:1px solid var(--border-color); }
        .chat-input button { margin-left: 8px; padding: 8px 15px; border-radius: 8px; background: var(--accent-primary); color: #fff; font-size: 0.875rem; cursor: pointer; border:none; }
        .chat-input button:hover { background: var(--accent-hover); }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(5px); } to { opacity: 1; transform: translateY(0); } }
        @media (min-width: 1024px) { .main-container { flex-direction: row; align-items: flex-start;} .controls-panel { width: 400px; flex-shrink: 0; max-height: 95vh; overflow-y: auto;} .chart-area-wrapper { flex-grow: 1;} #chartContainerWrapper { height: calc(95vh - 40px); /* Adjust based on padding/margins */}}
    </style>
</head>
<body>
    <div class="main-container">
        <div class="controls-panel">
            <h2 class="panel-title">Graph Configuration</h2>

            <h3 class="control-section-title">Data Input</h3>
            <div class="control-group">
                <label for="csvDataInput">CSV Data:</label>
                <textarea id="csvDataInput" rows="6" placeholder="LabelHeader,Series1Name,Series2Name,...\nLabel1,Value1A,Value1B,...\nLabel2,Value2A,Value2B,..."></textarea>
                <button id="loadCsvData">Load & Draw Graph</button>
            </div>

            <h3 class="control-section-title">General Settings</h3>
            <div class="grid-cols-controls">
                <div class="control-group">
                    <label for="chartTitleInput">Chart Title:</label>
                    <input type="text" id="chartTitleInput" value="My Custom Chart">
                </div>
                <div class="control-group">
                    <label for="chartTypeSelect">Chart Type:</label>
                    <select id="chartTypeSelect">
                        <option value="line">Line</option>
                        <option value="bar">Bar</option>
                        <option value="pie">Pie</option>
                        <option value="doughnut">Doughnut</option>
                        <option value="radar">Radar</option>
                        <option value="scatter">Scatter</option>
                        <option value="bubble">Bubble (Requires X,Y,Radius in CSV)</option>
                    </select>
                </div>
            </div>

            <h3 class="control-section-title">Dataset Customization</h3>
            <div id="datasetControlsContainer">
                <p class="text-sm text-text-secondary">Load CSV data to see dataset options.</p>
            </div>

            <div id="axisConfigContainer"> <h3 class="control-section-title">X-Axis</h3>
                <div class="grid-cols-controls">
                    <div class="control-group"><label for="xAxisTitle">Title:</label><input type="text" id="xAxisTitle" value="X-Axis"></div>
                    <div class="control-group"><label for="xAxisGrid">Show Grid:</label><input type="checkbox" id="xAxisGrid" checked></div>
                </div>

                <h3 class="control-section-title">Y-Axis (Primary)</h3>
                <div class="grid-cols-controls">
                    <div class="control-group"><label for="yAxisTitle">Title:</label><input type="text" id="yAxisTitle" value="Primary Y-Axis"></div>
                    <div class="control-group"><label for="yAxisMin">Min:</label><input type="number" id="yAxisMin" placeholder="auto"></div>
                    <div class="control-group"><label for="yAxisMax">Max:</label><input type="number" id="yAxisMax" placeholder="auto"></div>
                    <div class="control-group"><label for="yAxisStep">Step:</label><input type="number" id="yAxisStep" placeholder="auto"></div>
                    <div class="control-group"><label for="yAxisGrid">Show Grid:</label><input type="checkbox" id="yAxisGrid" checked></div>
                    <div class="control-group"><label for="yAxisLog">Logarithmic:</label><input type="checkbox" id="yAxisLog"></div>
                </div>

                <h3 class="control-section-title">Y-Axis (Secondary)</h3>
                <div class="grid-cols-controls">
                    <div class="control-group"><label for="y1AxisDisplay">Show Secondary Axis:</label><input type="checkbox" id="y1AxisDisplay"></div>
                    <div class="control-group"><label for="y1AxisTitle">Title:</label><input type="text" id="y1AxisTitle" value="Secondary Y-Axis"></div>
                    <div class="control-group"><label for="y1AxisMin">Min:</label><input type="number" id="y1AxisMin" placeholder="auto"></div>
                    <div class="control-group"><label for="y1AxisMax">Max:</label><input type="number" id="y1AxisMax" placeholder="auto"></div>
                    <div class="control-group"><label for="y1AxisStep">Step:</label><input type="number" id="y1AxisStep" placeholder="auto"></div>
                    <div class="control-group"><label for="y1AxisGrid">Show Grid:</label><input type="checkbox" id="y1AxisGrid"></div>
                    <div class="control-group"><label for="y1AxisLog">Logarithmic:</label><input type="checkbox" id="y1AxisLog"></div>
                </div>
            </div>

            <h3 class="control-section-title">Legend</h3>
            <div class="grid-cols-controls">
                <div class="control-group">
                    <label for="legendDisplay">Show Legend:</label>
                    <input type="checkbox" id="legendDisplay" checked>
                </div>
                <div class="control-group">
                    <label for="legendPosition">Position:</label>
                    <select id="legendPosition">
                        <option value="top">Top</option>
                        <option value="bottom">Bottom</option>
                        <option value="left">Left</option>
                        <option value="right">Right</option>
                        <option value="chartArea">Chart Area</option>
                    </select>
                </div>
            </div>
            
            <h3 class="control-section-title">Interactivity</h3>
             <div class="grid-cols-controls">
                <div class="control-group">
                    <label for="tooltipEnabled">Enable Tooltips:</label>
                    <input type="checkbox" id="tooltipEnabled" checked>
                </div>
            </div>


            <h3 class="control-section-title">Export</h3>
            <div class="control-group">
                <button id="exportChartPNG">Export as PNG</button>
                <button id="exportChartJPEG">Export as JPEG</button>
            </div>
             <div id="errorDisplay"></div>
        </div>

        <div class="controls-panel">
            <h2 class="panel-title">Stacked Bar Chart with Labels Inside Bars</h2>

            <!-- Graph Title -->
            <div class="control-group">
                <label for="stackedBarTitle">Graph Title:</label>
                <input type="text" id="stackedBarTitle" placeholder="Enter graph title" value="Stacked Bar Chart Example">
            </div>

            <!-- Add Graph Button -->
            <div class="control-group">
                <button id="addStackedBarChartBtn">Add Stacked Bar Chart</button>
            </div>

            <!-- Graph Container -->
            <div class="relative w-full h-[600px] sm:h-[700px] mt-4">
                <canvas id="stackedBarChartCanvas"></canvas>
            </div>
        </div>

        <div class="chart-area-wrapper">
            <div id="chartContainerWrapper">
                <canvas id="myChartCanvas"></canvas>
            </div>
        </div>
    </div>

    <div class="chat-container" id="aiChatContainer">
        <div class="chat-header">
            <span>AI Copilot</span>
            <button id="close-chat">Ã—</button>
        </div>
        <div class="chat-messages" id="chatMessages"></div>
        <div class="chat-input">
            <textarea id="userInput" rows="1" placeholder="Ask about the data..."></textarea>
            <button id="sendChatMessage">Send</button>
        </div>
    </div>

    <script>
        // Register the zoom plugin globally
        Chart.register(ChartZoom);

        let myChart;
        let activeChartData = { labels: [], datasets: [] };
        let chartConfig = {}; // To store all UI configurations

        const chartColors = [
            'rgba(54, 162, 235, 1)', 'rgba(255, 99, 132, 1)', 'rgba(75, 192, 192, 1)',
            'rgba(255, 206, 86, 1)', 'rgba(153, 102, 255, 1)', 'rgba(255, 159, 64, 1)',
            'rgba(201, 203, 207, 1)', 'rgba(0, 128, 128, 1)', 'rgba(128, 0, 128, 1)'
        ];
        const chartBgColors = chartColors.map(color => color.replace(', 1)', ', 0.5)'));

        const uiElements = {
            csvDataInput: document.getElementById('csvDataInput'),
            loadCsvDataBtn: document.getElementById('loadCsvData'),
            chartTitleInput: document.getElementById('chartTitleInput'),
            chartTypeSelect: document.getElementById('chartTypeSelect'),
            datasetControlsContainer: document.getElementById('datasetControlsContainer'),
            xAxisTitle: document.getElementById('xAxisTitle'),
            xAxisGrid: document.getElementById('xAxisGrid'),
            yAxisTitle: document.getElementById('yAxisTitle'),
            yAxisMin: document.getElementById('yAxisMin'),
            yAxisMax: document.getElementById('yAxisMax'),
            yAxisStep: document.getElementById('yAxisStep'),
            yAxisGrid: document.getElementById('yAxisGrid'),
            yAxisLog: document.getElementById('yAxisLog'),
            y1AxisDisplay: document.getElementById('y1AxisDisplay'),
            y1AxisTitle: document.getElementById('y1AxisTitle'),
            y1AxisMin: document.getElementById('y1AxisMin'),
            y1AxisMax: document.getElementById('y1AxisMax'),
            y1AxisStep: document.getElementById('y1AxisStep'),
            y1AxisGrid: document.getElementById('y1AxisGrid'),
            y1AxisLog: document.getElementById('y1AxisLog'),
            legendDisplay: document.getElementById('legendDisplay'),
            legendPosition: document.getElementById('legendPosition'),
            tooltipEnabled: document.getElementById('tooltipEnabled'),
            axisConfigContainer: document.getElementById('axisConfigContainer'),
            exportPNG: document.getElementById('exportChartPNG'),
            exportJPEG: document.getElementById('exportChartJPEG'),
            errorDisplay: document.getElementById('errorDisplay'),
            // Chat elements
            aiChatContainer: document.getElementById('aiChatContainer'),
            chatMessages: document.getElementById('chatMessages'),
            userInput: document.getElementById('userInput'),
            sendChatMessageBtn: document.getElementById('sendChatMessage'),
            closeChatBtn: document.getElementById('close-chat')
        };

        function displayError(message) {
            uiElements.errorDisplay.textContent = message;
            console.error(message);
        }

        function clearError() {
            uiElements.errorDisplay.textContent = '';
        }
        
        function parseCSV(csvString) {
            clearError();
            const lines = csvString.trim().split('\n');
            if (lines.length < 2) {
                displayError("CSV data must have at least a header and one data row.");
                return null;
            }

            const headers = lines[0].split(',').map(h => h.trim());
            const labels = [];
            const rawDatasets = headers.slice(1).map((header, index) => ({
                label: header,
                data: [],
                _raw_data_index: index // Store original index for mapping
            }));

            for (let i = 1; i < lines.length; i++) {
                const currentLine = lines[i].split(',');
                labels.push(currentLine[0].trim());
                for (let j = 1; j < currentLine.length; j++) {
                    if (rawDatasets[j - 1]) {
                        const valStr = currentLine[j] ? currentLine[j].trim() : null;
                        let val;
                        // For bubble charts, data might be objects {x, y, r}
                        // For now, assume simple numeric values or null
                        if (valStr === null || valStr === '') {
                            val = null;
                        } else {
                            val = parseFloat(valStr);
                            if (isNaN(val)) val = valStr; // Keep as string if not parsable to float, e.g. for categorical
                        }
                        rawDatasets[j - 1].data.push(val);
                    }
                }
            }
            return { labels, datasets: rawDatasets };
        }

        function generateDatasetControls() {
            uiElements.datasetControlsContainer.innerHTML = ''; // Clear previous
            if (!activeChartData.datasets || activeChartData.datasets.length === 0) {
                 uiElements.datasetControlsContainer.innerHTML = '<p class="text-sm text-text-secondary">Load CSV data to see dataset options.</p>';
                return;
            }

            activeChartData.datasets.forEach((dataset, index) => {
                const controlDiv = document.createElement('div');
                controlDiv.className = 'dataset-controls';
                controlDiv.innerHTML = `
                    <h4 class="text-sm font-semibold mb-1">${dataset.label || `Dataset ${index + 1}`}</h4>
                    <div class="grid-cols-controls">
                        <div class="control-group">
                            <label for="dsColor-${index}">Color:</label>
                            <input type="color" id="dsColor-${index}" value="${dataset.borderColor || chartColors[index % chartColors.length]}">
                        </div>
                        <div class="control-group">
                            <label for="dsYAxis-${index}">Y-Axis:</label>
                            <select id="dsYAxis-${index}">
                                <option value="y" ${dataset.yAxisID === 'y' || !dataset.yAxisID ? 'selected' : ''}>Primary (Y)</option>
                                <option value="y1" ${dataset.yAxisID === 'y1' ? 'selected' : ''}>Secondary (Y1)</option>
                            </select>
                        </div>
                    </div>
                `;
                uiElements.datasetControlsContainer.appendChild(controlDiv);

                document.getElementById(`dsColor-${index}`).addEventListener('input', (e) => {
                    dataset.borderColor = e.target.value;
                    dataset.backgroundColor = e.target.value.replace('1)', '0.5)'); // for area/bar fills
                    if (myChart) createOrUpdateChart();
                });
                document.getElementById(`dsYAxis-${index}`).addEventListener('change', (e) => {
                    dataset.yAxisID = e.target.value;
                    // Ensure the selected y-axis is enabled if a dataset is assigned to it
                    if (e.target.value === 'y1' && !uiElements.y1AxisDisplay.checked) {
                        uiElements.y1AxisDisplay.checked = true; 
                    }
                    if (myChart) createOrUpdateChart();
                });
            });
        }
        
        function getChartConfiguration() {
            const type = uiElements.chartTypeSelect.value;
            const isPieFamily = ['pie', 'doughnut', 'radar'].includes(type);
            uiElements.axisConfigContainer.style.display = isPieFamily ? 'none' : 'block';

            const datasets = activeChartData.datasets.map((ds, index) => {
                const colorInput = document.getElementById(`dsColor-${index}`);
                const yAxisSelect = document.getElementById(`dsYAxis-${index}`);
                
                const baseDatasetConfig = {
                    label: ds.label,
                    data: ds.data,
                    borderColor: colorInput ? colorInput.value : (ds.borderColor || chartColors[index % chartColors.length]),
                    backgroundColor: colorInput ? colorInput.value.replace(/, ?1\)/, ', 0.5)') : (ds.backgroundColor || chartBgColors[index % chartBgColors.length]),
                    yAxisID: yAxisSelect ? yAxisSelect.value : (ds.yAxisID || 'y'),
                    tension: type === 'line' ? 0.1 : undefined, // Example type-specific option
                    borderWidth: 1,
                };

                // Specifics for bubble charts: data needs to be {x, y, r}
                // This needs robust CSV parsing to identify x, y, r columns
                if (type === 'bubble' && ds.data.every(p => typeof p === 'object' && p !== null && 'x' in p && 'y' in p && 'r' in p)) {
                    // Data is already in correct format, or needs to be transformed
                } else if (type === 'bubble') {
                    // Attempt a simple transformation if 3 numeric values are found per label
                    // This is a placeholder for more intelligent parsing
                    baseDatasetConfig.data = activeChartData.labels.map((label, i) => {
                        const xVal = parseFloat(label); // Assuming labels might be X for scatter/bubble
                        const yVal = parseFloat(ds.data[i]);
                        const rVal = ds.data.length > i + 1 && parseFloat(ds.data[i+1]) ? parseFloat(ds.data[i+1]) : 10; // Needs better logic
                        return {x: xVal || i, y: yVal || 0, r: rVal || 5};
                    });
                }
                 // For pie/doughnut/radar, data is often a single array of values, and colors are per segment
                if (isPieFamily) {
                    baseDatasetConfig.backgroundColor = ds.data.map((_, i) => chartBgColors[(index + i) % chartBgColors.length]);
                    baseDatasetConfig.borderColor = ds.data.map((_, i) => chartColors[(index + i) % chartColors.length]);
                }


                return baseDatasetConfig;
            });

            const hasY1Assigned = datasets.some(ds => ds.yAxisID === 'y1');
            const showY1 = uiElements.y1AxisDisplay.checked && hasY1Assigned;
            uiElements.y1AxisDisplay.checked = showY1; // Sync checkbox if y1 is auto-enabled/disabled

            return {
                type: type,
                data: {
                    labels: activeChartData.labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        title: { display: true, text: uiElements.chartTitleInput.value, font: {size: 16}, color: 'var(--text-primary)' },
                        legend: {
                            display: uiElements.legendDisplay.checked,
                            position: uiElements.legendPosition.value,
                            labels: { color: 'var(--text-primary)' }
                        },
                        tooltip: { enabled: uiElements.tooltipEnabled.checked },
                        zoom: { // Zoom plugin configuration
                            pan: { enabled: true, mode: 'xy', threshold: 5, },
                            zoom: { wheel: { enabled: true }, pinch: { enabled: true }, mode: 'xy', }
                        }
                    },
                    scales: isPieFamily ? {} : { // No scales for pie/doughnut/radar
                        x: {
                            title: { display: true, text: uiElements.xAxisTitle.value, color: 'var(--text-primary)' },
                            grid: { display: uiElements.xAxisGrid.checked, color: 'var(--border-color)' },
                            ticks: { color: 'var(--text-primary)' }
                        },
                        y: {
                            title: { display: true, text: uiElements.yAxisTitle.value, color: 'var(--text-primary)' },
                            min: uiElements.yAxisMin.value ? parseFloat(uiElements.yAxisMin.value) : undefined,
                            max: uiElements.yAxisMax.value ? parseFloat(uiElements.yAxisMax.value) : undefined,
                            ticks: {
                                stepSize: uiElements.yAxisStep.value ? parseFloat(uiElements.yAxisStep.value) : undefined,
                                color: 'var(--text-primary)'
                            },
                            grid: { display: uiElements.yAxisGrid.checked, color: 'var(--border-color)' },
                            type: uiElements.yAxisLog.checked ? 'logarithmic' : 'linear'
                        },
                        y1: showY1 ? {
                            position: 'right',
                            title: { display: true, text: uiElements.y1AxisTitle.value, color: 'var(--text-primary)' },
                            min: uiElements.y1AxisMin.value ? parseFloat(uiElements.y1AxisMin.value) : undefined,
                            max: uiElements.y1AxisMax.value ? parseFloat(uiElements.y1AxisMax.value) : undefined,
                            ticks: {
                                stepSize: uiElements.y1AxisStep.value ? parseFloat(uiElements.y1AxisStep.value) : undefined,
                                color: 'var(--text-primary)'
                            },
                            grid: { display: uiElements.y1AxisGrid.checked, drawOnChartArea: uiElements.y1AxisGrid.checked, color: 'var(--border-color)' }, // Only draw grid if yAxisGrid for y1 is checked
                            type: uiElements.y1AxisLog.checked ? 'logarithmic' : 'linear'
                        } : { display: false }
                    },
                    onClick: (event) => { // AI Copilot trigger
                        const elements = myChart.getElementsAtEventForMode(event, 'nearest', { intersect: true }, true);
                        if (elements.length > 0) {
                            const element = elements[0];
                            const datasetIndex = element.datasetIndex;
                            const dataIndex = element.index;
                            const datasetLabel = myChart.data.datasets[datasetIndex].label;
                            const xValue = myChart.data.labels[dataIndex];
                            const yValue = myChart.data.datasets[datasetIndex].data[dataIndex];
                            let queryValue = yValue;
                            if (typeof yValue === 'object' && yValue !== null) { // For scatter/bubble
                                queryValue = `(x: ${yValue.x}, y: ${yValue.y}${yValue.r ? ', r: ' + yValue.r : ''})`;
                            }
                            const query = `Tell me about the data point: ${datasetLabel} at ${xValue}, value is ${queryValue}. Chart title: ${myChart.options.plugins.title.text}`;
                            uiElements.aiChatContainer.style.display = 'flex';
                            sendAIChatQuery(query);
                        }
                    }
                }
            };
        }

        function createOrUpdateChart() {
            clearError();
            if (!activeChartData.labels.length && !activeChartData.datasets.length && uiElements.csvDataInput.value.trim() === '') {
                 displayError("Please load data using the CSV input.");
                 // Optionally, render an empty state chart or placeholder message
                 if (myChart) myChart.destroy();
                 const ctx = document.getElementById('myChartCanvas').getContext('2d');
                 ctx.clearRect(0,0, ctx.canvas.width, ctx.canvas.height);
                 ctx.textAlign = "center";
                 ctx.fillStyle = 'var(--text-secondary)';
                 ctx.fillText("Load CSV data to draw a chart.", ctx.canvas.width / 2, ctx.canvas.height / 2);
                return;
            }
             if (!activeChartData.datasets.length && uiElements.csvDataInput.value.trim() !== '') {
                 displayError("Could not parse datasets from CSV. Check format.");
                 return;
             }


            const config = getChartConfiguration();
            const ctx = document.getElementById('myChartCanvas').getContext('2d');

            if (myChart) {
                myChart.destroy();
            }
            try {
                myChart = new Chart(ctx, config);
            } catch (e) {
                displayError("Error creating chart: " + e.message);
                console.error(e);
            }
        }
        
        uiElements.loadCsvDataBtn.addEventListener('click', () => {
            const csvText = uiElements.csvDataInput.value;
            if (!csvText.trim()) {
                displayError("CSV data input is empty.");
                activeChartData = { labels: [], datasets: [] }; // Clear data
                generateDatasetControls(); // Clear dataset controls
                createOrUpdateChart(); // Attempt to clear chart or show empty state
                return;
            }
            const parsed = parseCSV(csvText);
            if (parsed) {
                activeChartData = {
                    labels: parsed.labels,
                    // Initialize dataset properties that will be customized by UI
                    datasets: parsed.datasets.map((ds, index) => ({
                        ...ds, // Raw data and label
                        borderColor: chartColors[index % chartColors.length],
                        backgroundColor: chartBgColors[index % chartBgColors.length],
                        yAxisID: index === 0 ? 'y' : (index === 1 ? 'y1' : 'y') // Default assignment
                    }))
                };
                generateDatasetControls();
                createOrUpdateChart();
            } else {
                 activeChartData = { labels: [], datasets: [] };
                 generateDatasetControls();
            }
        });

        // Event listeners for all other controls to redraw chart
        [
            uiElements.chartTitleInput, uiElements.chartTypeSelect,
            uiElements.xAxisTitle, uiElements.xAxisGrid,
            uiElements.yAxisTitle, uiElements.yAxisMin, uiElements.yAxisMax, uiElements.yAxisStep, uiElements.yAxisGrid, uiElements.yAxisLog,
            uiElements.y1AxisDisplay, uiElements.y1AxisTitle, uiElements.y1AxisMin, uiElements.y1AxisMax, uiElements.y1AxisStep, uiElements.y1AxisGrid, uiElements.y1AxisLog,
            uiElements.legendDisplay, uiElements.legendPosition, uiElements.tooltipEnabled
        ].forEach(el => {
            const eventType = (el.type === 'checkbox' || el.type === 'select-one') ? 'change' : 'input';
            el.addEventListener(eventType, () => {
                if(myChart || activeChartData.labels.length > 0) createOrUpdateChart();
            });
        });


        // Export functionality
        function exportChart(format = 'png') {
            if (myChart) {
                const imageLink = document.createElement('a');
                const fileNameBase = uiElements.chartTitleInput.value.replace(/[^a-z0-9]/gi, '_').toLowerCase() || 'chart';
                imageLink.download = `${fileNameBase}.${format}`;
                imageLink.href = myChart.toBase64Image(format === 'jpeg' ? 'image/jpeg' : 'image/png', 1.0);
                document.body.appendChild(imageLink);
                imageLink.click();
                document.body.removeChild(imageLink);
            } else {
                displayError("No chart to export.");
            }
        }
        uiElements.exportPNG.addEventListener('click', () => exportChart('png'));
        uiElements.exportJPEG.addEventListener('click', () => exportChart('jpeg'));

        // --- AI Chat Copilot (modified from previous) ---
        function appendAIChatMessage(text, sender) {
            const wrapper = document.createElement('div');
            wrapper.className = 'message ' + sender;
            const avatar = document.createElement('div');
            avatar.className = 'avatar';
            avatar.textContent = sender === 'user' ? 'U' : 'AI';
            const bubble = document.createElement('div');
            bubble.className = 'bubble';
            bubble.textContent = text;
            wrapper.append(avatar, bubble);
            uiElements.chatMessages.appendChild(wrapper);
            uiElements.chatMessages.scrollTop = uiElements.chatMessages.scrollHeight;
        }

        async function sendAIChatQuery(text) {
            if (!text.trim()) return;
            appendAIChatMessage(text, 'user');
            if (uiElements.userInput.value === text) uiElements.userInput.value = ''; // Clear input if it was from user typing

            appendAIChatMessage("AI is thinking...", 'bot typing'); // Typing indicator

            try {
                // Replace with your actual AI API endpoint and request structure
                const response = await fetch('https://ai-api-al6k.onrender.com/ask', { // Placeholder API
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ text: text, context: "User is analyzing a chart." }) // Send query and some context
                });

                const typingIndicator = uiElements.chatMessages.querySelector('.bot.typing');
                if (typingIndicator) typingIndicator.remove();

                if (!response.ok) {
                    const errorData = await response.text();
                    throw new Error(`API request failed: ${response.status} - ${errorData}`);
                }
                const data = await response.json();
                const aiResponse = data.response || data.text || "Sorry, I couldn't process that.";
                appendAIChatMessage(aiResponse, 'bot');

            } catch (err) {
                const typingIndicator = uiElements.chatMessages.querySelector('.bot.typing');
                if (typingIndicator) typingIndicator.remove();
                appendAIChatMessage(`Error: ${err.message}`, 'bot error');
                console.error('AI API error:', err);
            }
        }

        uiElements.sendChatMessageBtn.addEventListener('click', () => sendAIChatQuery(uiElements.userInput.value));
        uiElements.userInput.addEventListener('keydown', e => {
            if (e.key === 'Enter' && !e.shiftKey) {
                e.preventDefault();
                sendAIChatQuery(uiElements.userInput.value);
            }
        });
        uiElements.closeChatBtn.addEventListener('click', () => {
            uiElements.aiChatContainer.style.display = 'none';
        });

        // Initial placeholder chart
        createOrUpdateChart(); 
        generateDatasetControls(); // To show the "load data" message
        
        // Make chat draggable (simple version)
        let isChatDragging = false; let chatOffsetX, chatOffsetY;
        const chatHeader = uiElements.aiChatContainer.querySelector('.chat-header');
        if (chatHeader) {
            chatHeader.addEventListener('mousedown', (e) => {
                isChatDragging = true;
                chatOffsetX = e.clientX - uiElements.aiChatContainer.offsetLeft;
                chatOffsetY = e.clientY - uiElements.aiChatContainer.offsetTop;
                chatHeader.style.cursor = 'grabbing';
            });
        }
        document.addEventListener('mousemove', (e) => {
            if (!isChatDragging) return;
            uiElements.aiChatContainer.style.left = (e.clientX - chatOffsetX) + 'px';
            uiElements.aiChatContainer.style.top = (e.clientY - chatOffsetY) + 'px';
        });
        document.addEventListener('mouseup', () => {
            if (isChatDragging) {
                isChatDragging = false;
                if(chatHeader) chatHeader.style.cursor = 'grab';
            }
        });

        // Function to parse CSV data and create a grouped stacked bar chart
        document.getElementById('addStackedBarChartBtn').addEventListener('click', () => {
            const csvData = document.getElementById('csvDataInput').value.trim();
            if (!csvData) {
                alert('Please provide CSV data to create the chart.');
                return;
            }

            // Parse the CSV data
            const lines = csvData.split('\n');
            const headers = lines[0].split(',').map(header => header.trim());
            const countries = headers.slice(1); // Country names (e.g., USA, Bangladesh)
            const activities = [];
            const datasets = countries.map((country, index) => ({
                label: country,
                data: [],
                backgroundColor: `rgba(${54 + index * 50}, ${162 - index * 30}, ${235 - index * 40}, 0.8)`,
            }));

            for (let i = 1; i < lines.length; i++) {
                const values = lines[i].split(',').map(value => value.trim());
                activities.push(values[0]); // First column is the activity
                for (let j = 1; j < values.length; j++) {
                    datasets[j - 1].data.push(parseFloat(values[j]) || 0); // Parse numeric values
                }
            }

            // Chart configuration
            const ctx = document.getElementById('stackedBarChartCanvas').getContext('2d');
            new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: countries, // Countries as the X-axis labels
                    datasets: activities.map((activity, activityIndex) => ({
                        label: activity,
                        data: datasets.map(dataset => dataset.data[activityIndex]),
                        backgroundColor: `rgba(${54 + activityIndex * 50}, ${162 - activityIndex * 30}, ${235 - activityIndex * 40}, 0.8)`,
                    })),
                },
                options: {
                    plugins: {
                        title: {
                            display: true,
                            text: document.getElementById('stackedBarTitle').value || 'Grouped Stacked Bar Chart',
                            font: { size: 16 },
                            padding: { top: 10, bottom: 20 },
                        },
                        legend: {
                            position: 'top',
                            labels: {
                                font: { size: 14 },
                                boxWidth: 24,
                                padding: 15,
                            },
                        },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    const value = context.raw;
                                    return `${context.dataset.label}: ${value}`;
                                },
                            },
                        },
                    },
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Countries',
                                font: { size: 16 },
                                padding: { top: 10 },
                            },
                            ticks: {
                                font: { size: 14 },
                            },
                        },
                        y: {
                            stacked: true,
                            title: {
                                display: true,
                                text: 'Values',
                                font: { size: 16 },
                                padding: { bottom: 10 },
                            },
                            ticks: {
                                font: { size: 14 },
                                callback: value => value.toLocaleString(),
                            },
                        },
                    },
                    animation: {
                        duration: 1000,
                        easing: 'easeOutQuart',
                    },
                },
            });
        });
    </script>
</body>
</html>